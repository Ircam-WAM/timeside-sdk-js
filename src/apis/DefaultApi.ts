/* tslint:disable */
/* eslint-disable */
/**
 * TimeSide API
 * RESTful API of TimeSide, a scalable audio processing framework.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Analysis,
    AnalysisFromJSON,
    AnalysisToJSON,
    AnalysisTrack,
    AnalysisTrackFromJSON,
    AnalysisTrackToJSON,
    Annotation,
    AnnotationFromJSON,
    AnnotationToJSON,
    AnnotationTrack,
    AnnotationTrackFromJSON,
    AnnotationTrackToJSON,
    Experience,
    ExperienceFromJSON,
    ExperienceToJSON,
    InlineObject,
    InlineObjectFromJSON,
    InlineObjectToJSON,
    InlineObject1,
    InlineObject1FromJSON,
    InlineObject1ToJSON,
    InlineObject2,
    InlineObject2FromJSON,
    InlineObject2ToJSON,
    Item,
    ItemFromJSON,
    ItemToJSON,
    ItemList,
    ItemListFromJSON,
    ItemListToJSON,
    ItemWaveform,
    ItemWaveformFromJSON,
    ItemWaveformToJSON,
    Preset,
    PresetFromJSON,
    PresetToJSON,
    Processor,
    ProcessorFromJSON,
    ProcessorToJSON,
    ProcessorList,
    ProcessorListFromJSON,
    ProcessorListToJSON,
    Provider,
    ProviderFromJSON,
    ProviderToJSON,
    Result,
    ResultFromJSON,
    ResultToJSON,
    Selection,
    SelectionFromJSON,
    SelectionToJSON,
    Task,
    TaskFromJSON,
    TaskToJSON,
    User,
    UserFromJSON,
    UserToJSON,
} from '../models';

export interface CreateAnalysisRequest {
    body?: Analysis;
}

export interface CreateAnalysisTrackRequest {
    body?: AnalysisTrack;
}

export interface CreateAnnotationRequest {
    body?: Annotation;
}

export interface CreateAnnotationTrackRequest {
    body?: AnnotationTrack;
}

export interface CreateExperienceRequest {
    body?: Experience;
}

export interface CreateItemRequest {
    body?: Item;
}

export interface CreatePresetRequest {
    body?: Preset;
}

export interface CreateSelectionRequest {
    body?: Selection;
}

export interface CreateTaskRequest {
    body?: Task;
}

export interface CreateTokenObtainPairRequest {
    body?: InlineObject;
}

export interface CreateTokenRefreshRequest {
    body?: InlineObject1;
}

export interface CreateTokenVerifyRequest {
    body?: InlineObject2;
}

export interface DestroyAnalysisRequest {
    uuid: string;
}

export interface DestroyAnalysisTrackRequest {
    uuid: string;
}

export interface DestroyAnnotationRequest {
    uuid: string;
}

export interface DestroyAnnotationTrackRequest {
    uuid: string;
}

export interface DestroyExperienceRequest {
    uuid: string;
}

export interface DestroyItemRequest {
    uuid: string;
    search?: string;
}

export interface DestroyPresetRequest {
    uuid: string;
}

export interface DestroySelectionRequest {
    uuid: string;
}

export interface DestroyTaskRequest {
    uuid: string;
}

export interface ListItemsRequest {
    search?: string;
}

export interface ListResultsRequest {
    search?: string;
}

export interface ParametersDefaultAnalysisTrackRequest {
    uuid: string;
}

export interface ParametersDefaultProcessorRequest {
    pid: string;
}

export interface ParametersSchemaProcessorRequest {
    pid: string;
}

export interface PartialUpdateAnalysisRequest {
    uuid: string;
    body?: Analysis;
}

export interface PartialUpdateAnalysisTrackRequest {
    uuid: string;
    body?: AnalysisTrack;
}

export interface PartialUpdateAnnotationRequest {
    uuid: string;
    body?: Annotation;
}

export interface PartialUpdateAnnotationTrackRequest {
    uuid: string;
    body?: AnnotationTrack;
}

export interface PartialUpdateExperienceRequest {
    uuid: string;
    body?: Experience;
}

export interface PartialUpdateItemRequest {
    uuid: string;
    search?: string;
    body?: Item;
}

export interface PartialUpdatePresetRequest {
    uuid: string;
    body?: Preset;
}

export interface PartialUpdateSelectionRequest {
    uuid: string;
    body?: Selection;
}

export interface PartialUpdateTaskRequest {
    uuid: string;
    body?: Task;
}

export interface RetrieveAnalysisRequest {
    uuid: string;
}

export interface RetrieveAnalysisTrackRequest {
    uuid: string;
}

export interface RetrieveAnnotationRequest {
    uuid: string;
}

export interface RetrieveAnnotationTrackRequest {
    uuid: string;
}

export interface RetrieveExperienceRequest {
    uuid: string;
}

export interface RetrieveItemRequest {
    uuid: string;
    search?: string;
}

export interface RetrieveItem0Request {
    uuid: string;
}

export interface RetrievePresetRequest {
    uuid: string;
}

export interface RetrieveProcessorRequest {
    pid: string;
}

export interface RetrieveProviderRequest {
    uuid: string;
}

export interface RetrieveResultRequest {
    uuid: string;
    search?: string;
}

export interface RetrieveResult0Request {
    uuid: string;
}

export interface RetrieveSelectionRequest {
    uuid: string;
}

export interface RetrieveTaskRequest {
    uuid: string;
}

export interface RetrieveUserRequest {
    username: string;
}

export interface SetParametersAnalysisTrackRequest {
    uuid: string;
    body?: AnalysisTrack;
}

export interface UpdateAnalysisRequest {
    uuid: string;
    body?: Analysis;
}

export interface UpdateAnalysisTrackRequest {
    uuid: string;
    body?: AnalysisTrack;
}

export interface UpdateAnnotationRequest {
    uuid: string;
    body?: Annotation;
}

export interface UpdateAnnotationTrackRequest {
    uuid: string;
    body?: AnnotationTrack;
}

export interface UpdateExperienceRequest {
    uuid: string;
    body?: Experience;
}

export interface UpdateItemRequest {
    uuid: string;
    search?: string;
    body?: Item;
}

export interface UpdatePresetRequest {
    uuid: string;
    body?: Preset;
}

export interface UpdateSelectionRequest {
    uuid: string;
    body?: Selection;
}

export interface UpdateTaskRequest {
    uuid: string;
    body?: Task;
}

/**
 * no description
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     */
    async createAnalysisRaw(requestParameters: CreateAnalysisRequest): Promise<runtime.ApiResponse<Analysis>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/analysis/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AnalysisToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisFromJSON(jsonValue));
    }

    /**
     */
    async createAnalysis(requestParameters: CreateAnalysisRequest): Promise<Analysis> {
        const response = await this.createAnalysisRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async createAnalysisTrackRaw(requestParameters: CreateAnalysisTrackRequest): Promise<runtime.ApiResponse<AnalysisTrack>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/analysis_tracks/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AnalysisTrackToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisTrackFromJSON(jsonValue));
    }

    /**
     */
    async createAnalysisTrack(requestParameters: CreateAnalysisTrackRequest): Promise<AnalysisTrack> {
        const response = await this.createAnalysisTrackRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async createAnnotationRaw(requestParameters: CreateAnnotationRequest): Promise<runtime.ApiResponse<Annotation>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/annotations/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AnnotationToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
    }

    /**
     */
    async createAnnotation(requestParameters: CreateAnnotationRequest): Promise<Annotation> {
        const response = await this.createAnnotationRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async createAnnotationTrackRaw(requestParameters: CreateAnnotationTrackRequest): Promise<runtime.ApiResponse<AnnotationTrack>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/annotation_tracks/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AnnotationTrackToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationTrackFromJSON(jsonValue));
    }

    /**
     */
    async createAnnotationTrack(requestParameters: CreateAnnotationTrackRequest): Promise<AnnotationTrack> {
        const response = await this.createAnnotationTrackRaw(requestParameters);
        return await response.value();
    }

    /**
     * Set of presets and other experiences.
     */
    async createExperienceRaw(requestParameters: CreateExperienceRequest): Promise<runtime.ApiResponse<Experience>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/experiences/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExperienceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExperienceFromJSON(jsonValue));
    }

    /**
     * Set of presets and other experiences.
     */
    async createExperience(requestParameters: CreateExperienceRequest): Promise<Experience> {
        const response = await this.createExperienceRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async createItemRaw(requestParameters: CreateItemRequest): Promise<runtime.ApiResponse<Item>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/items/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ItemToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemFromJSON(jsonValue));
    }

    /**
     */
    async createItem(requestParameters: CreateItemRequest): Promise<Item> {
        const response = await this.createItemRaw(requestParameters);
        return await response.value();
    }

    /**
     * Processor with its potential parameters.
     */
    async createPresetRaw(requestParameters: CreatePresetRequest): Promise<runtime.ApiResponse<Preset>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/presets/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PresetToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PresetFromJSON(jsonValue));
    }

    /**
     * Processor with its potential parameters.
     */
    async createPreset(requestParameters: CreatePresetRequest): Promise<Preset> {
        const response = await this.createPresetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Set of items and other selections.
     */
    async createSelectionRaw(requestParameters: CreateSelectionRequest): Promise<runtime.ApiResponse<Selection>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/selections/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SelectionToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SelectionFromJSON(jsonValue));
    }

    /**
     * Set of items and other selections.
     */
    async createSelection(requestParameters: CreateSelectionRequest): Promise<Selection> {
        const response = await this.createSelectionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async createTaskRaw(requestParameters: CreateTaskRequest): Promise<runtime.ApiResponse<Task>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/tasks/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TaskToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskFromJSON(jsonValue));
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async createTask(requestParameters: CreateTaskRequest): Promise<Task> {
        const response = await this.createTaskRaw(requestParameters);
        return await response.value();
    }

    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     */
    async createTokenObtainPairRaw(requestParameters: CreateTokenObtainPairRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/token/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObjectToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     */
    async createTokenObtainPair(requestParameters: CreateTokenObtainPairRequest): Promise<object> {
        const response = await this.createTokenObtainPairRaw(requestParameters);
        return await response.value();
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     */
    async createTokenRefreshRaw(requestParameters: CreateTokenRefreshRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/token/refresh/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject1ToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     */
    async createTokenRefresh(requestParameters: CreateTokenRefreshRequest): Promise<object> {
        const response = await this.createTokenRefreshRaw(requestParameters);
        return await response.value();
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     */
    async createTokenVerifyRaw(requestParameters: CreateTokenVerifyRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/token/verify/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject2ToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     */
    async createTokenVerify(requestParameters: CreateTokenVerifyRequest): Promise<object> {
        const response = await this.createTokenVerifyRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async destroyAnalysisRaw(requestParameters: DestroyAnalysisRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling destroyAnalysis.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/analysis/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async destroyAnalysis(requestParameters: DestroyAnalysisRequest): Promise<void> {
        await this.destroyAnalysisRaw(requestParameters);
    }

    /**
     */
    async destroyAnalysisTrackRaw(requestParameters: DestroyAnalysisTrackRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling destroyAnalysisTrack.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/analysis_tracks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async destroyAnalysisTrack(requestParameters: DestroyAnalysisTrackRequest): Promise<void> {
        await this.destroyAnalysisTrackRaw(requestParameters);
    }

    /**
     */
    async destroyAnnotationRaw(requestParameters: DestroyAnnotationRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling destroyAnnotation.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/annotations/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async destroyAnnotation(requestParameters: DestroyAnnotationRequest): Promise<void> {
        await this.destroyAnnotationRaw(requestParameters);
    }

    /**
     */
    async destroyAnnotationTrackRaw(requestParameters: DestroyAnnotationTrackRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling destroyAnnotationTrack.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/annotation_tracks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async destroyAnnotationTrack(requestParameters: DestroyAnnotationTrackRequest): Promise<void> {
        await this.destroyAnnotationTrackRaw(requestParameters);
    }

    /**
     * Set of presets and other experiences.
     */
    async destroyExperienceRaw(requestParameters: DestroyExperienceRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling destroyExperience.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/experiences/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set of presets and other experiences.
     */
    async destroyExperience(requestParameters: DestroyExperienceRequest): Promise<void> {
        await this.destroyExperienceRaw(requestParameters);
    }

    /**
     */
    async destroyItemRaw(requestParameters: DestroyItemRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling destroyItem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/items/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async destroyItem(requestParameters: DestroyItemRequest): Promise<void> {
        await this.destroyItemRaw(requestParameters);
    }

    /**
     * Processor with its potential parameters.
     */
    async destroyPresetRaw(requestParameters: DestroyPresetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling destroyPreset.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/presets/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Processor with its potential parameters.
     */
    async destroyPreset(requestParameters: DestroyPresetRequest): Promise<void> {
        await this.destroyPresetRaw(requestParameters);
    }

    /**
     * Set of items and other selections.
     */
    async destroySelectionRaw(requestParameters: DestroySelectionRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling destroySelection.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/selections/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set of items and other selections.
     */
    async destroySelection(requestParameters: DestroySelectionRequest): Promise<void> {
        await this.destroySelectionRaw(requestParameters);
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async destroyTaskRaw(requestParameters: DestroyTaskRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling destroyTask.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/tasks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async destroyTask(requestParameters: DestroyTaskRequest): Promise<void> {
        await this.destroyTaskRaw(requestParameters);
    }

    /**
     */
    async listAnalysisRaw(): Promise<runtime.ApiResponse<Array<Analysis>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/analysis/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AnalysisFromJSON));
    }

    /**
     */
    async listAnalysis(): Promise<Array<Analysis>> {
        const response = await this.listAnalysisRaw();
        return await response.value();
    }

    /**
     */
    async listAnalysisTracksRaw(): Promise<runtime.ApiResponse<Array<AnalysisTrack>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/analysis_tracks/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AnalysisTrackFromJSON));
    }

    /**
     */
    async listAnalysisTracks(): Promise<Array<AnalysisTrack>> {
        const response = await this.listAnalysisTracksRaw();
        return await response.value();
    }

    /**
     */
    async listAnnotationTracksRaw(): Promise<runtime.ApiResponse<Array<AnnotationTrack>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/annotation_tracks/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AnnotationTrackFromJSON));
    }

    /**
     */
    async listAnnotationTracks(): Promise<Array<AnnotationTrack>> {
        const response = await this.listAnnotationTracksRaw();
        return await response.value();
    }

    /**
     */
    async listAnnotationsRaw(): Promise<runtime.ApiResponse<Array<Annotation>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/annotations/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AnnotationFromJSON));
    }

    /**
     */
    async listAnnotations(): Promise<Array<Annotation>> {
        const response = await this.listAnnotationsRaw();
        return await response.value();
    }

    /**
     */
    async listCsrfTokensRaw(): Promise<runtime.ApiResponse<Array<object>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/token-csrf/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     */
    async listCsrfTokens(): Promise<Array<object>> {
        const response = await this.listCsrfTokensRaw();
        return await response.value();
    }

    /**
     * Set of presets and other experiences.
     */
    async listExperiencesRaw(): Promise<runtime.ApiResponse<Array<Experience>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/experiences/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ExperienceFromJSON));
    }

    /**
     * Set of presets and other experiences.
     */
    async listExperiences(): Promise<Array<Experience>> {
        const response = await this.listExperiencesRaw();
        return await response.value();
    }

    /**
     */
    async listItemsRaw(requestParameters: ListItemsRequest): Promise<runtime.ApiResponse<Array<ItemList>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/items/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ItemListFromJSON));
    }

    /**
     */
    async listItems(requestParameters: ListItemsRequest): Promise<Array<ItemList>> {
        const response = await this.listItemsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Processor with its potential parameters.
     */
    async listPresetsRaw(): Promise<runtime.ApiResponse<Array<Preset>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/presets/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PresetFromJSON));
    }

    /**
     * Processor with its potential parameters.
     */
    async listPresets(): Promise<Array<Preset>> {
        const response = await this.listPresetsRaw();
        return await response.value();
    }

    /**
     * Audio process to compute on items given potential parameters
     */
    async listProcessorsRaw(): Promise<runtime.ApiResponse<Array<ProcessorList>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/processors/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProcessorListFromJSON));
    }

    /**
     * Audio process to compute on items given potential parameters
     */
    async listProcessors(): Promise<Array<ProcessorList>> {
        const response = await this.listProcessorsRaw();
        return await response.value();
    }

    /**
     * Audio providers available in the API.
     */
    async listProvidersRaw(): Promise<runtime.ApiResponse<Array<Provider>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/providers/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProviderFromJSON));
    }

    /**
     * Audio providers available in the API.
     */
    async listProviders(): Promise<Array<Provider>> {
        const response = await this.listProvidersRaw();
        return await response.value();
    }

    /**
     * Result of processing on items.
     */
    async listResultsRaw(requestParameters: ListResultsRequest): Promise<runtime.ApiResponse<Array<Result>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/results/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ResultFromJSON));
    }

    /**
     * Result of processing on items.
     */
    async listResults(requestParameters: ListResultsRequest): Promise<Array<Result>> {
        const response = await this.listResultsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Set of items and other selections.
     */
    async listSelectionsRaw(): Promise<runtime.ApiResponse<Array<Selection>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/selections/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SelectionFromJSON));
    }

    /**
     * Set of items and other selections.
     */
    async listSelections(): Promise<Array<Selection>> {
        const response = await this.listSelectionsRaw();
        return await response.value();
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async listTasksRaw(): Promise<runtime.ApiResponse<Array<Task>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/tasks/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TaskFromJSON));
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async listTasks(): Promise<Array<Task>> {
        const response = await this.listTasksRaw();
        return await response.value();
    }

    /**
     * Users of the API able to share data.
     */
    async listUsersRaw(): Promise<runtime.ApiResponse<Array<User>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/users/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserFromJSON));
    }

    /**
     * Users of the API able to share data.
     */
    async listUsers(): Promise<Array<User>> {
        const response = await this.listUsersRaw();
        return await response.value();
    }

    /**
     */
    async parametersDefaultAnalysisTrackRaw(requestParameters: ParametersDefaultAnalysisTrackRequest): Promise<runtime.ApiResponse<AnalysisTrack>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling parametersDefaultAnalysisTrack.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/analysis_tracks/{uuid}/parameters_default/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisTrackFromJSON(jsonValue));
    }

    /**
     */
    async parametersDefaultAnalysisTrack(requestParameters: ParametersDefaultAnalysisTrackRequest): Promise<AnalysisTrack> {
        const response = await this.parametersDefaultAnalysisTrackRaw(requestParameters);
        return await response.value();
    }

    /**
     * Audio process to compute on items given potential parameters
     */
    async parametersDefaultProcessorRaw(requestParameters: ParametersDefaultProcessorRequest): Promise<runtime.ApiResponse<Processor>> {
        if (requestParameters.pid === null || requestParameters.pid === undefined) {
            throw new runtime.RequiredError('pid','Required parameter requestParameters.pid was null or undefined when calling parametersDefaultProcessor.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/processors/{pid}/parameters_default/`.replace(`{${"pid"}}`, encodeURIComponent(String(requestParameters.pid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessorFromJSON(jsonValue));
    }

    /**
     * Audio process to compute on items given potential parameters
     */
    async parametersDefaultProcessor(requestParameters: ParametersDefaultProcessorRequest): Promise<Processor> {
        const response = await this.parametersDefaultProcessorRaw(requestParameters);
        return await response.value();
    }

    /**
     * Audio process to compute on items given potential parameters
     */
    async parametersSchemaProcessorRaw(requestParameters: ParametersSchemaProcessorRequest): Promise<runtime.ApiResponse<Processor>> {
        if (requestParameters.pid === null || requestParameters.pid === undefined) {
            throw new runtime.RequiredError('pid','Required parameter requestParameters.pid was null or undefined when calling parametersSchemaProcessor.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/processors/{pid}/parameters_schema/`.replace(`{${"pid"}}`, encodeURIComponent(String(requestParameters.pid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessorFromJSON(jsonValue));
    }

    /**
     * Audio process to compute on items given potential parameters
     */
    async parametersSchemaProcessor(requestParameters: ParametersSchemaProcessorRequest): Promise<Processor> {
        const response = await this.parametersSchemaProcessorRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async partialUpdateAnalysisRaw(requestParameters: PartialUpdateAnalysisRequest): Promise<runtime.ApiResponse<Analysis>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling partialUpdateAnalysis.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/analysis/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AnalysisToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisFromJSON(jsonValue));
    }

    /**
     */
    async partialUpdateAnalysis(requestParameters: PartialUpdateAnalysisRequest): Promise<Analysis> {
        const response = await this.partialUpdateAnalysisRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async partialUpdateAnalysisTrackRaw(requestParameters: PartialUpdateAnalysisTrackRequest): Promise<runtime.ApiResponse<AnalysisTrack>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling partialUpdateAnalysisTrack.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/analysis_tracks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AnalysisTrackToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisTrackFromJSON(jsonValue));
    }

    /**
     */
    async partialUpdateAnalysisTrack(requestParameters: PartialUpdateAnalysisTrackRequest): Promise<AnalysisTrack> {
        const response = await this.partialUpdateAnalysisTrackRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async partialUpdateAnnotationRaw(requestParameters: PartialUpdateAnnotationRequest): Promise<runtime.ApiResponse<Annotation>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling partialUpdateAnnotation.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/annotations/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AnnotationToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
    }

    /**
     */
    async partialUpdateAnnotation(requestParameters: PartialUpdateAnnotationRequest): Promise<Annotation> {
        const response = await this.partialUpdateAnnotationRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async partialUpdateAnnotationTrackRaw(requestParameters: PartialUpdateAnnotationTrackRequest): Promise<runtime.ApiResponse<AnnotationTrack>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling partialUpdateAnnotationTrack.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/annotation_tracks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AnnotationTrackToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationTrackFromJSON(jsonValue));
    }

    /**
     */
    async partialUpdateAnnotationTrack(requestParameters: PartialUpdateAnnotationTrackRequest): Promise<AnnotationTrack> {
        const response = await this.partialUpdateAnnotationTrackRaw(requestParameters);
        return await response.value();
    }

    /**
     * Set of presets and other experiences.
     */
    async partialUpdateExperienceRaw(requestParameters: PartialUpdateExperienceRequest): Promise<runtime.ApiResponse<Experience>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling partialUpdateExperience.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/experiences/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ExperienceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExperienceFromJSON(jsonValue));
    }

    /**
     * Set of presets and other experiences.
     */
    async partialUpdateExperience(requestParameters: PartialUpdateExperienceRequest): Promise<Experience> {
        const response = await this.partialUpdateExperienceRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async partialUpdateItemRaw(requestParameters: PartialUpdateItemRequest): Promise<runtime.ApiResponse<Item>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling partialUpdateItem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/items/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ItemToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemFromJSON(jsonValue));
    }

    /**
     */
    async partialUpdateItem(requestParameters: PartialUpdateItemRequest): Promise<Item> {
        const response = await this.partialUpdateItemRaw(requestParameters);
        return await response.value();
    }

    /**
     * Processor with its potential parameters.
     */
    async partialUpdatePresetRaw(requestParameters: PartialUpdatePresetRequest): Promise<runtime.ApiResponse<Preset>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling partialUpdatePreset.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/presets/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PresetToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PresetFromJSON(jsonValue));
    }

    /**
     * Processor with its potential parameters.
     */
    async partialUpdatePreset(requestParameters: PartialUpdatePresetRequest): Promise<Preset> {
        const response = await this.partialUpdatePresetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Set of items and other selections.
     */
    async partialUpdateSelectionRaw(requestParameters: PartialUpdateSelectionRequest): Promise<runtime.ApiResponse<Selection>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling partialUpdateSelection.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/selections/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SelectionToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SelectionFromJSON(jsonValue));
    }

    /**
     * Set of items and other selections.
     */
    async partialUpdateSelection(requestParameters: PartialUpdateSelectionRequest): Promise<Selection> {
        const response = await this.partialUpdateSelectionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async partialUpdateTaskRaw(requestParameters: PartialUpdateTaskRequest): Promise<runtime.ApiResponse<Task>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling partialUpdateTask.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/tasks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TaskToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskFromJSON(jsonValue));
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async partialUpdateTask(requestParameters: PartialUpdateTaskRequest): Promise<Task> {
        const response = await this.partialUpdateTaskRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async retrieveAnalysisRaw(requestParameters: RetrieveAnalysisRequest): Promise<runtime.ApiResponse<Analysis>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveAnalysis.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/analysis/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisFromJSON(jsonValue));
    }

    /**
     */
    async retrieveAnalysis(requestParameters: RetrieveAnalysisRequest): Promise<Analysis> {
        const response = await this.retrieveAnalysisRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async retrieveAnalysisTrackRaw(requestParameters: RetrieveAnalysisTrackRequest): Promise<runtime.ApiResponse<AnalysisTrack>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveAnalysisTrack.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/analysis_tracks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisTrackFromJSON(jsonValue));
    }

    /**
     */
    async retrieveAnalysisTrack(requestParameters: RetrieveAnalysisTrackRequest): Promise<AnalysisTrack> {
        const response = await this.retrieveAnalysisTrackRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async retrieveAnnotationRaw(requestParameters: RetrieveAnnotationRequest): Promise<runtime.ApiResponse<Annotation>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveAnnotation.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/annotations/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
    }

    /**
     */
    async retrieveAnnotation(requestParameters: RetrieveAnnotationRequest): Promise<Annotation> {
        const response = await this.retrieveAnnotationRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async retrieveAnnotationTrackRaw(requestParameters: RetrieveAnnotationTrackRequest): Promise<runtime.ApiResponse<AnnotationTrack>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveAnnotationTrack.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/annotation_tracks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationTrackFromJSON(jsonValue));
    }

    /**
     */
    async retrieveAnnotationTrack(requestParameters: RetrieveAnnotationTrackRequest): Promise<AnnotationTrack> {
        const response = await this.retrieveAnnotationTrackRaw(requestParameters);
        return await response.value();
    }

    /**
     * Set of presets and other experiences.
     */
    async retrieveExperienceRaw(requestParameters: RetrieveExperienceRequest): Promise<runtime.ApiResponse<Experience>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveExperience.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/experiences/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExperienceFromJSON(jsonValue));
    }

    /**
     * Set of presets and other experiences.
     */
    async retrieveExperience(requestParameters: RetrieveExperienceRequest): Promise<Experience> {
        const response = await this.retrieveExperienceRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async retrieveItemRaw(requestParameters: RetrieveItemRequest): Promise<runtime.ApiResponse<Item>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveItem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/items/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemFromJSON(jsonValue));
    }

    /**
     */
    async retrieveItem(requestParameters: RetrieveItemRequest): Promise<Item> {
        const response = await this.retrieveItemRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gives audio waveform of an item.
     */
    async retrieveItem_1Raw(requestParameters: RetrieveItem0Request): Promise<runtime.ApiResponse<ItemWaveform>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveItem_1.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/items/{uuid}/waveform/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemWaveformFromJSON(jsonValue));
    }

    /**
     * Gives audio waveform of an item.
     */
    async retrieveItem_1(requestParameters: RetrieveItem0Request): Promise<ItemWaveform> {
        const response = await this.retrieveItem_1Raw(requestParameters);
        return await response.value();
    }

    /**
     * Processor with its potential parameters.
     */
    async retrievePresetRaw(requestParameters: RetrievePresetRequest): Promise<runtime.ApiResponse<Preset>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrievePreset.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/presets/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PresetFromJSON(jsonValue));
    }

    /**
     * Processor with its potential parameters.
     */
    async retrievePreset(requestParameters: RetrievePresetRequest): Promise<Preset> {
        const response = await this.retrievePresetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Audio process to compute on items given potential parameters
     */
    async retrieveProcessorRaw(requestParameters: RetrieveProcessorRequest): Promise<runtime.ApiResponse<Processor>> {
        if (requestParameters.pid === null || requestParameters.pid === undefined) {
            throw new runtime.RequiredError('pid','Required parameter requestParameters.pid was null or undefined when calling retrieveProcessor.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/processors/{pid}/`.replace(`{${"pid"}}`, encodeURIComponent(String(requestParameters.pid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessorFromJSON(jsonValue));
    }

    /**
     * Audio process to compute on items given potential parameters
     */
    async retrieveProcessor(requestParameters: RetrieveProcessorRequest): Promise<Processor> {
        const response = await this.retrieveProcessorRaw(requestParameters);
        return await response.value();
    }

    /**
     * Audio providers available in the API.
     */
    async retrieveProviderRaw(requestParameters: RetrieveProviderRequest): Promise<runtime.ApiResponse<Provider>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveProvider.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/providers/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProviderFromJSON(jsonValue));
    }

    /**
     * Audio providers available in the API.
     */
    async retrieveProvider(requestParameters: RetrieveProviderRequest): Promise<Provider> {
        const response = await this.retrieveProviderRaw(requestParameters);
        return await response.value();
    }

    /**
     * Result of processing on items.
     */
    async retrieveResultRaw(requestParameters: RetrieveResultRequest): Promise<runtime.ApiResponse<Result>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveResult.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/results/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ResultFromJSON(jsonValue));
    }

    /**
     * Result of processing on items.
     */
    async retrieveResult(requestParameters: RetrieveResultRequest): Promise<Result> {
        const response = await this.retrieveResultRaw(requestParameters);
        return await response.value();
    }

    /**
     * PNG rendering of 2D numerical data (example: a spectrogram).
     */
    async retrieveResult_2Raw(requestParameters: RetrieveResult0Request): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveResult_2.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/results/{uuid}/visual/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * PNG rendering of 2D numerical data (example: a spectrogram).
     */
    async retrieveResult_2(requestParameters: RetrieveResult0Request): Promise<object> {
        const response = await this.retrieveResult_2Raw(requestParameters);
        return await response.value();
    }

    /**
     * Set of items and other selections.
     */
    async retrieveSelectionRaw(requestParameters: RetrieveSelectionRequest): Promise<runtime.ApiResponse<Selection>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveSelection.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/selections/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SelectionFromJSON(jsonValue));
    }

    /**
     * Set of items and other selections.
     */
    async retrieveSelection(requestParameters: RetrieveSelectionRequest): Promise<Selection> {
        const response = await this.retrieveSelectionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async retrieveTaskRaw(requestParameters: RetrieveTaskRequest): Promise<runtime.ApiResponse<Task>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling retrieveTask.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/tasks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskFromJSON(jsonValue));
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async retrieveTask(requestParameters: RetrieveTaskRequest): Promise<Task> {
        const response = await this.retrieveTaskRaw(requestParameters);
        return await response.value();
    }

    /**
     * Users of the API able to share data.
     */
    async retrieveUserRaw(requestParameters: RetrieveUserRequest): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new runtime.RequiredError('username','Required parameter requestParameters.username was null or undefined when calling retrieveUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/timeside/api/users/{username}/`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters.username))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Users of the API able to share data.
     */
    async retrieveUser(requestParameters: RetrieveUserRequest): Promise<User> {
        const response = await this.retrieveUserRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async setParametersAnalysisTrackRaw(requestParameters: SetParametersAnalysisTrackRequest): Promise<runtime.ApiResponse<AnalysisTrack>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling setParametersAnalysisTrack.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/analysis_tracks/{uuid}/set_parameters/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AnalysisTrackToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisTrackFromJSON(jsonValue));
    }

    /**
     */
    async setParametersAnalysisTrack(requestParameters: SetParametersAnalysisTrackRequest): Promise<AnalysisTrack> {
        const response = await this.setParametersAnalysisTrackRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async updateAnalysisRaw(requestParameters: UpdateAnalysisRequest): Promise<runtime.ApiResponse<Analysis>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateAnalysis.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/analysis/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AnalysisToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisFromJSON(jsonValue));
    }

    /**
     */
    async updateAnalysis(requestParameters: UpdateAnalysisRequest): Promise<Analysis> {
        const response = await this.updateAnalysisRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async updateAnalysisTrackRaw(requestParameters: UpdateAnalysisTrackRequest): Promise<runtime.ApiResponse<AnalysisTrack>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateAnalysisTrack.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/analysis_tracks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AnalysisTrackToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnalysisTrackFromJSON(jsonValue));
    }

    /**
     */
    async updateAnalysisTrack(requestParameters: UpdateAnalysisTrackRequest): Promise<AnalysisTrack> {
        const response = await this.updateAnalysisTrackRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async updateAnnotationRaw(requestParameters: UpdateAnnotationRequest): Promise<runtime.ApiResponse<Annotation>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateAnnotation.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/annotations/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AnnotationToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
    }

    /**
     */
    async updateAnnotation(requestParameters: UpdateAnnotationRequest): Promise<Annotation> {
        const response = await this.updateAnnotationRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async updateAnnotationTrackRaw(requestParameters: UpdateAnnotationTrackRequest): Promise<runtime.ApiResponse<AnnotationTrack>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateAnnotationTrack.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/annotation_tracks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AnnotationTrackToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationTrackFromJSON(jsonValue));
    }

    /**
     */
    async updateAnnotationTrack(requestParameters: UpdateAnnotationTrackRequest): Promise<AnnotationTrack> {
        const response = await this.updateAnnotationTrackRaw(requestParameters);
        return await response.value();
    }

    /**
     * Set of presets and other experiences.
     */
    async updateExperienceRaw(requestParameters: UpdateExperienceRequest): Promise<runtime.ApiResponse<Experience>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateExperience.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/experiences/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ExperienceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExperienceFromJSON(jsonValue));
    }

    /**
     * Set of presets and other experiences.
     */
    async updateExperience(requestParameters: UpdateExperienceRequest): Promise<Experience> {
        const response = await this.updateExperienceRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async updateItemRaw(requestParameters: UpdateItemRequest): Promise<runtime.ApiResponse<Item>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateItem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/items/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ItemToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemFromJSON(jsonValue));
    }

    /**
     */
    async updateItem(requestParameters: UpdateItemRequest): Promise<Item> {
        const response = await this.updateItemRaw(requestParameters);
        return await response.value();
    }

    /**
     * Processor with its potential parameters.
     */
    async updatePresetRaw(requestParameters: UpdatePresetRequest): Promise<runtime.ApiResponse<Preset>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updatePreset.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/presets/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PresetToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PresetFromJSON(jsonValue));
    }

    /**
     * Processor with its potential parameters.
     */
    async updatePreset(requestParameters: UpdatePresetRequest): Promise<Preset> {
        const response = await this.updatePresetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Set of items and other selections.
     */
    async updateSelectionRaw(requestParameters: UpdateSelectionRequest): Promise<runtime.ApiResponse<Selection>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateSelection.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/selections/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SelectionToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SelectionFromJSON(jsonValue));
    }

    /**
     * Set of items and other selections.
     */
    async updateSelection(requestParameters: UpdateSelectionRequest): Promise<Selection> {
        const response = await this.updateSelectionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async updateTaskRaw(requestParameters: UpdateTaskRequest): Promise<runtime.ApiResponse<Task>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateTask.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/timeside/api/tasks/{uuid}/`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TaskToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskFromJSON(jsonValue));
    }

    /**
     * Experience applied to a selection or a single item.
     */
    async updateTask(requestParameters: UpdateTaskRequest): Promise<Task> {
        const response = await this.updateTaskRaw(requestParameters);
        return await response.value();
    }

}
